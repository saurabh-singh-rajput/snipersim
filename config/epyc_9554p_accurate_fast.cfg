# Accurate AMD EPYC 9554P 64-Core Processor configuration
# Optimized for speed while maintaining ranking accuracy
# Based on actual system specifications: Zen 4, family 25, model 17

[general]
arch = intel
mode = 64
magic = false
roi_script = false
inst_mode_init = cache_only
inst_mode_roi = cache_only    # Use cache_only instead of detailed for speed
inst_mode_end = fast_forward
inst_mode_output = true
syntax = intel
issue_memops_at_functional = false
num_host_cores = 0
enable_signals = false
signals_to_ignore = 13
enable_smc_support = false
enable_pinplay = false
enable_syscall_emulation = true
suppress_stdout = false
suppress_stderr = false

# Simulate fewer cores for single-threaded apps, but maintain accurate per-core modeling
total_cores = 8              # Reduced from 64 for speed, but keeps accurate core model

enable_icache_modeling = true

[log]
enabled = false
stack_trace = false
disabled_modules = ""
enabled_modules = ""
mutex_trace = false
pin_codecache_trace = false
circular_log = false

[progress_trace]
enabled = false
interval = 5000
filename = ""

[clock_skew_minimization]
scheme = barrier
report = false

[clock_skew_minimization/barrier]
quantum = 1000               # Increased for better performance

# Core model based on actual EPYC 9554P Zen 4 specifications
[perf_model/core]
frequency = 1.5              # Current actual frequency from lscpu
type = interval              # Keep interval model for accurate energy modeling
core_model = nehalem         # Use nehalem as base, but tune parameters for Zen 4
logical_cpus = 2             # Actual SMT capability

# Zen 4 microarchitecture parameters
[perf_model/core/interval_timer]
dispatch_width = 6           # Zen 4 has 6-wide dispatch (keep accurate)
window_size = 128            # Reduced from 192 for speed, but still representative
issue_contention = true
num_outstanding_loadstores = 16  # Keep accurate for memory-bound code ranking
memory_dependency_granularity = 8
lll_dependency_granularity = 64
lll_cutoff = 30
issue_memops_at_dispatch = false

# Instruction costs tuned for Zen 4 characteristics
[perf_model/core/static_instruction_costs]
add=1
sub=1
mul=3                        # Zen 4 integer multiply latency
div=18                       # Zen 4 integer divide latency
fadd=3                       # Zen 4 FP add latency
fsub=3                       # Zen 4 FP sub latency
fmul=4                       # Zen 4 FP multiply latency
fdiv=10                      # Zen 4 FP divide latency (reduced from 6 for accuracy)
generic=1
jmp=1
string=1
branch=1
dynamic_misc=1
recv=1
sync=0
spawn=0
tlb_miss=0
mem_access=0
delay=0
unknown=0

# Branch predictor - Zen 4 specifications
[perf_model/branch_predictor]
type=pentium_m
mispredict_penalty=16        # Zen 4 branch misprediction penalty
size=4096                    # Representative branch predictor size

# TLB configuration based on actual specs
[perf_model/tlb]
penalty = 30
penalty_parallel = true

[perf_model/itlb]
size = 64                    # Zen 4 ITLB size
associativity = 4

[perf_model/dtlb]
size = 64                    # Zen 4 DTLB size
associativity = 4

[perf_model/stlb]
size = 512                   # Zen 4 L2 TLB size
associativity = 4

# Accurate cache hierarchy based on actual system specs
[perf_model/cache]
levels = 3

# L1 Instruction Cache - actual specs: 32KB per core, 8-way
[perf_model/l1_icache]
perfect = false
cache_size = 32              # Actual per-core size
cache_block_size = 64
associativity = 8            # Actual associativity
address_hash = mask
replacement_policy = lru
data_access_time = 4         # Zen 4 L1I access time
tags_access_time = 1
perf_model_type = parallel
writethrough = 0
shared_cores = 1

# L1 Data Cache - actual specs: 32KB per core, 8-way
[perf_model/l1_dcache]
perfect = false
cache_size = 32              # Actual per-core size
associativity = 8            # Actual associativity
address_hash = mask
replacement_policy = lru
data_access_time = 4         # Zen 4 L1D access time
tags_access_time = 1
perf_model_type = parallel
writethrough = 0
shared_cores = 1

# L2 Cache - actual specs: 1MB per core
[perf_model/l2_cache]
perfect = false
cache_size = 1024            # Actual per-core size (1MB)
associativity = 8            # Zen 4 L2 associativity
address_hash = mask
replacement_policy = lru
data_access_time = 12        # Zen 4 L2 access time
tags_access_time = 3
perf_model_type = parallel
writethrough = 0
shared_cores = 1

# L3 Cache - actual specs: 32MB per 8 cores (CCX)
[perf_model/l3_cache]
cache_block_size = 64
cache_size = 4096            # 32MB / 8 cores = 4MB effective per core in this model
associativity = 16           # Zen 4 L3 associativity
address_hash = mask
replacement_policy = lru
dvfs_domain = global
prefetcher = none
writeback_time = 0
shared_cores = 8             # Actual sharing pattern
writethrough = 0
perf_model_type = parallel
tags_access_time = 15        # Zen 4 L3 access time
data_access_time = 45

[perf_model/fast_forward]
model = oneipc
interval = 100000            # Keep reasonable interval
include_memory_latency = true  # Important for energy accuracy
include_branch_misprediction = false

[core]
spin_loop_detection = true   # Enable for better single-thread performance

[core/light_cache]
num = 0

[core/cheetah]
enabled = false

[core/hook_periodic_ins]
ins_per_core = 10000
ins_global = 1000000

[caching_protocol]
type = parametric_dram_directory_msi
variant = mesi

# DRAM directory - simplified but functional
[perf_model/dram_directory]
total_entries = 65536        # Reduced but adequate
associativity = 8            # Simplified
max_hw_sharers = 8           # Matches our core count
directory_type = full_map
home_lookup_param = 6
directory_cache_access_time = 10
locations = dram
interleaving = 1

[perf_model/dram_directory/limitless]
software_trap_penalty = 200

# DRAM configuration - representative of DDR4/DDR5
[perf_model/dram]
type = constant
latency = 80                 # Typical DDR4 latency
per_controller_bandwidth = 25.6  # Representative bandwidth
num_controllers = 1          # Simplified
controllers_interleaving = 1
controller_positions = ""
direct_access = false

[perf_model/dram/normal]
standard_deviation = 0

[perf_model/dram/cache]
enabled = false

[perf_model/dram/queue_model]
enabled = true
type = history_list

[perf_model/nuca]
enabled = false

[perf_model/sync]
reschedule_cost = 1000

# Network configuration - simplified but functional
[network]
memory_model_1 = emesh_hop_counter
system_model = emesh_hop_counter
collect_traffic_matrix = false

[network/emesh_hop_counter]
link_bandwidth = 128
hop_latency = 1

[network/emesh_hop_by_hop]
link_bandwidth = 128
hop_latency = 1
concentration = 1
dimensions = 2
wrap_around = false
size = ""

[network/emesh_hop_by_hop/queue_model]
enabled = true
type = history_list

[network/emesh_hop_by_hop/broadcast_tree]
enabled = false

[network/bus]
ignore_local_traffic = true

[network/bus/queue_model]
type=contention

[queue_model/basic]
moving_avg_enabled = true
moving_avg_window_size = 1024
moving_avg_type = arithmetic_mean

[queue_model/history_list]
max_list_size = 100
analytical_model_enabled = true

[queue_model/windowed_mg1]
window_size = 1000

# DVFS configuration
[dvfs]
type = simple
transition_latency = 1000

[dvfs/simple]
cores_per_socket = 8         # Matches our total_cores

[bbv]
sampling = 0

[loop_tracer]
iter_start = 0
iter_count = 36

[osemu]
pthread_replace = false
nprocs = 0
clock_replace = true
time_start = 1337000000

[traceinput]
enabled = false
address_randomization = false
stop_with_first_app = true
restart_apps = false
mirror_output = false
trace_prefix = ""
num_runs = 1
timeout = 360

# Scheduler - use static for predictability
[scheduler]
type = static

[scheduler/static]
core_mask = 1

[hooks]
numscripts = 0

[fault_injection]
type = none
injector = none

[routine_tracer]
type = none

[instruction_tracer]
type = none

[sampling]
enabled = false